The reduction rules of lambda calculus are defined using substitution.
Substitution of the variable ğ‘¥ in a lambda term ğ‘’ with another lambda term ğ‘£ is
denoted ğ‘’[ğ‘¥ := ğ‘£].

Substitution is not allowed to cause variables that are free in ğ‘£ to become
bound in ğ‘’[ğ‘¥ := ğ‘£], as this changes the meaning of the function. For example,
the substitution '(Î»x. y)[y := x]' would result in 'Î»x. x', but this is not
allowed as x is free in 'x' but becomes bound in 'Î»x. x'. This can be avoided
by applying Î±-conversion; see the page on Î±-conversion for more information.

More formally, substitution obeys the following rewrite rules, in which ğ‘¥ and ğ‘¦
are variables and ğ‘’, ğ‘£, and ğ‘¢ are lambda terms:
ğ‘¥[ğ‘¥ := ğ‘£] â†’ ğ‘£
ğ‘¦[ğ‘¥ := ğ‘£] â†’ ğ‘¦   if ğ‘¥ â‰  ğ‘¦
(ğ‘’ ğ‘¢)[ğ‘¥ := ğ‘£] â†’ ğ‘’[ğ‘¥ := ğ‘£] ğ‘¢[ğ‘¥ := ğ‘£]
(Î»ğ‘¥. ğ‘’)[ğ‘¥ := ğ‘£] â†’ Î»ğ‘¥. ğ‘’
(Î»ğ‘¦. ğ‘’)[ğ‘¥ := ğ‘£] â†’ Î»ğ‘¦. ğ‘’[ğ‘¥ := ğ‘£]   if ğ‘¥ â‰  ğ‘¦ and ğ‘¦ is not free in ğ‘£

Since the '[ğ‘¥ := ğ‘£]' syntax is not part of the lambda calculus, it is not valid
for a reduction to result in a term that contains a substitution that cannot be
reduced using the above rules. Thankfully, in all such cases Î±-conversion can
be applied to obtain a term that can be reduced using the above rules.